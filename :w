use crate::{ChangeRequest, extract_player_indicies};
use crate::engine::change_request::{
    ChangeArgs, ChangeResult, FilterFuncPtr, StateChangeFuncPtr, check_len,
};
use crate::engine::player::roles::Roles;
use std::fmt::Display;
use std::ops::Deref;

use crate::engine::{
    change_request::{ChangeError, ChangeRequestBuilder, ChangeType},
    player::{Alignment, CharacterType, roles::Role},
    state::{PlayerIndex, State},
};

#[derive(Default, Debug, Clone)]
pub(crate) struct Imp {
    pub(crate) last_killed: Option<usize>,
}

impl Role for Imp {
    fn get_default_alignment(&self) -> Alignment {
        Alignment::Evil
    }

    fn get_true_character_type(&self) -> CharacterType {
        CharacterType::Demon
    }

    fn night_order(&self) -> Option<usize> {
        Some(34)
    }

    fn is_win_condition(&self) -> bool {
        true
    }

    fn night_ability(
        &self,
        player_index: PlayerIndex,
        state: &State,
    ) -> Option<ChangeRequestBuilder> {
        let dead = state.get_player(player_index).dead;
        if dead {
            return None;
        }

        let day_num = state.day_num;

        if let Some(prev_day_num) = self.last_killed
            && prev_day_num == day_num
        {
            return None;
        }

        return ChangeRequest::new_builder(
            ChangeType::ChoosePlayers(1),
            "Ask the Imp to point to the player they would like to kill".into(),
        )
        .state_change_func(StateChangeFuncPtr::new(move |state, args| {
            let target_players = match args {
                ChangeArgs::PlayerIndices(pi) => pi,
                _ => return Some(ChangeError::WrongArgType),
            };
            check_len(&target_players, 1)?;
            let target_player_index = target_players[0];
            state.kill(player_index, target_player_index);
            state.change_request_queue.push_back(
                // WARN: Unused description
                ChangeRequest::new_builder(ChangeType::NoStoryteller, String::new())
                    .state_change_func(StateChangeFuncPtr::new(|state, args| {
                        if let Roles::Imp(Imp {
                            last_killed: Some(day_num),
                            ..
                        }) = &state.get_player(player_index).role
                        {
                            if *day_num == state.day_num {
                                return;
                            }
                        }

                        if target_player_index == player_index
                            && state.get_player(player_index).dead
                        {
                            state.change_request_queue.push_back(Imp::new_imp());
                        }

                        None
                    })),
            );

            None
        }))
        .into();
    }
}

impl Imp {
    fn new_imp() -> ChangeRequestBuilder {
        return ChangeRequest::new_builder(ChangeType::ChoosePlayers(1), "Choose a new Imp".into())
            .state_change_func(StateChangeFuncPtr::new(move |state, args| {
                let target_players = extract_player_indicies!(args);
                };
                check_len(&target_players, 1)?;

                let target_player_index = target_players[0];
                let target_player = state.get_player(target_player_index);
                if target_player.role.get_true_character_type() != CharacterType::Minion {
                    return Some(ChangeError::InvalidSelectedPlayer {
                        reason: "Cannot select a non-minion to become the new imp".into(),
                    });
                }
                let target_player_index = target_players[0];
                let day_num = state.day_num;
                let target_player = state.get_player_mut(target_player_index);

                let new_role = Roles::Imp(Imp {
                    last_killed: Some(day_num),
                });

                target_player.role = new_role;
                None
            }))
            .filter_func(FilterFuncPtr::new(move |_, player| {
                player.role.get_true_character_type() == CharacterType::Minion
            }))
            .into();
    }
}

impl Display for Imp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str("Imp")
    }
}
